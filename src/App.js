import * as THREE from 'three'
import { useRef, useState, useMemo } from 'react'
import { easing } from 'maath'
import { Canvas, useFrame } from '@react-three/fiber'
import { useControls } from 'leva'
import {
  useGLTF,
  GizmoHelper,
  GizmoViewport,
  OrbitControls,
  Center,
  Caustics,
  Environment,
  Lightformer,
  RandomizedLight,
  PerformanceMonitor,
  AccumulativeShadows,
  MeshTransmissionMaterial
} from '@react-three/drei'
import { PivotControls } from './pivotControls/index'
import Models from './Models'
const innerMaterial = new THREE.MeshStandardMaterial({
  transparent: true,
  opacity: 1,
  color: 'black',
  roughness: 0,
  side: THREE.FrontSide,
  blending: THREE.AdditiveBlending,
  polygonOffset: true,
  polygonOffsetFactor: 1,
  envMapIntensity: 2
})

export default function App() {
  const options = useMemo(() => {
    return {
      x: { value: 0, min: 0, max: Math.PI * 2, step: 0.01 },
      y: { value: 0, min: 0, max: Math.PI * 2, step: 0.01 },
      z: { value: 0, min: 0, max: Math.PI * 2, step: 0.01 },
      visible: true,
      color: { value: '#0000f0' }
    }
  }, [])

  const pB = useControls('Polyhedron B', options)
  //const debug_mode = true

  const [perfSucks, degrade] = useState(false)
  return (
    <Canvas
      shadows
      dpr={[1, perfSucks ? 1.5 : 2]}
      eventSource={document.getElementById('root')}
      eventPrefix="client"
      camera={{ position: [20, 0.9, 20], fov: 26 }}>
      {/** PerfMon will detect performance issues */}
      <PerformanceMonitor onDecline={() => degrade(true)} />
      <color attach="background" args={[pB.color]} />
      <group position={[0, -0.5, 0]} rotation={[0, -0.75, 0]}>
        <Scene />
        <OrbitControls makeDefault />
        <AccumulativeShadows visible={true} frames={100} alphaTest={0.85} opacity={0.9} color={pB.color} scale={20} position={[0, -0.005, 0]}>
          <RandomizedLight amount={8} radius={6} ambient={0.5} intensity={1} position={[-1.5, 2.5, -2.5]} bias={0.001} />
        </AccumulativeShadows>
      </group>
      <Env perfSucks={perfSucks} />
    </Canvas>
  )
}

/*
Kit-bash auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.3 scene.glb --transform
Licenses: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Authors:
  matousekfoto (https://sketchfab.com/matousekfoto) (Fruit Cake Slice)
    https://sketchfab.com/3d-models/fruit-cake-slice-7b9a33386eab4dd986aa0980054ead3c
  Felix Yadomi (https://sketchfab.com/felixyadomi) (Cute milkshake)
    https://sketchfab.com/3d-models/cute-milkshake-3ba52a41b4b248df953684861d9e7a20
  Second Studio (https://sketchfab.com/kayaaku) (Dry flower)
    https://sketchfab.com/3d-models/dry-flower-ff0005d6eb4d4077bd08b8992299c45c
  CDcruz (https://sketchfab.com/cdcruz) (Ikea - Pokal Glass Cups)
    https://sketchfab.com/3d-models/ikea-pokal-glass-cups-21837e54a14346aa900e1ae719779b86
*/
const gltf_name = 'glass-transformed.glb'
function Scene(props) {
  const { nodes, materials } = useGLTF('/' + gltf_name)
  console.log(nodes)
  const scene_options = useMemo(() => {
    return {
      x: { value: 26, min: 0, max: 50, step: 0.1 },
      y: { value: 0, min: 0, max: Math.PI * 2, step: 0.01 },
      z: { value: 0, min: 0, max: Math.PI * 2, step: 0.01 },
      visible: true,
      color: { value: 'lime' }
    }
  }, [])

  const pA = useControls('Scene', scene_options)
  return (
    <group {...props} dispose={null}>
      <PivotControls rotation={[0, -Math.PI / 2, 0]} anchor={[1, -1, -1]} scale={75} depthTest={false} fixed lineWidth={2}>
        <mesh castShadow rotation={[0, -0.5, 0]} geometry={nodes.Scene.children[7].geometry} material={materials.FruitCakeSlice_u1_v1} />
      </PivotControls>
      <Models />
      <mesh castShadow geometry={nodes.straw_1.geometry} material={materials.straw_2} />
      <mesh castShadow geometry={nodes.straw_2.geometry} material={materials.straw_1} />
      <mesh castShadow position={[0, -0.005, 0]} geometry={nodes.straw001_1.geometry} material={materials.straw_2} />
      <mesh castShadow position={[0, -0.005, 0]} geometry={nodes.straw001_2.geometry} material={materials.straw_1} />
      <Center rotation={[0, -0.4, 0]} position={[-1, -0.01, -2]} top>
        <mesh scale={1.2} castShadow geometry={nodes.flowers.geometry} material={materials['draifrawer_u1_v1.001']} />
      </Center>
      <mesh castShadow geometry={nodes.fork.geometry} material={materials.ForkAndKnivesSet001_1K} material-color="#999" />
      <Caustics
        backfaces
        color={[1, 0.8, 0.8]}
        focus={[0, -1.2, 0]}
        lightSource={[-2, 2.5, -2.5]}
        frustum={1.75}
        intensity={0.005}
        worldRadius={0.66 / 10}
        ior={0.6}
        backfaceIor={1.26}>
        <mesh castShadow receiveShadow geometry={nodes.glass.geometry}>
          console.log()
          <MeshTransmissionMaterial thickness={0.2} chromaticAberration={0.05} anisotropy={1.5} clearcoat={1} clearcoatRoughness={0.2} envMapIntensity={3} />
        </mesh>
      </Caustics>
      {/** Some hacks to get some back face reflections, otherwise the glass would look fake */}
      <mesh scale={[0.95, 1, 0.95]} geometry={nodes.glass_back.geometry} material={innerMaterial} />
      <mesh geometry={nodes.glass_inner.geometry} material={innerMaterial} />
    </group>
  )
}

function Env({ perfSucks }) {
  const ref = useRef()
  const light_opt1 = useMemo(() => {
    return {
      intensity: { value: 4, min: 0, max: 40, step: 0.01 },
      rotation: { value: { x: Math.PI / 2, y: 0, z: 0 }, step: 0.1 },
      position: { value: { x: 0, y: 5, z: -9 }, step: 0.1 },
      scale: { value: { x: 10, y: 10, z: 1 }, step: 0.1 },

      visible: true,
      color: { value: 'lime' }
    }
  }, [])
  // const light_op1 = new light_options()
  const pLight1 = useControls('lights', light_opt1)

  useFrame((state, delta) => {
    // Animate the environment as well as the camera
    {
      /*
    if (!perfSucks) {
      easing.damp3(ref.current.rotation, [Math.PI / 2, 0, state.clock.elapsedTime / 5 + state.pointer.x], 0.2, delta)
      easing.damp3(state.camera.position, [Math.sin(state.pointer.x / 4) * 9, 1.25 + state.pointer.y, Math.cos(state.pointer.x / 4) * 9], 0.5, delta)
      state.camera.lookAt(0, 0, 0)

      //console.log(ref.color)
    }
    */
    }
    //if () {
    //}
    //ref.current.rotation.y += 1
  })

  // Runtime environments can be too slow on some systems, better safe than sorry with PerfMon
  return (
    <Environment frames={perfSucks ? 1 : Infinity} preset="city" resolution={256} background blur={0.8}>
      <Lightformer visible={pLight1.visible} intensity={pLight1.intensity} rotation={[pLight1.rotation]} position={pLight1.position} scale={pLight1.scale} />
      <Lightformer visible={true} intensity={4} rotation-x={Math.PI / 2} position={[0, 5, -9]} scale={[10, 10, 1]} />
      <group rotation={[Math.PI / 2, 1, 0]}>
        {[2, -2, 2, -4, 2, -5, 2, -9].map((x, i) => (
          <Lightformer key={i} intensity={1} rotation={[Math.PI / 4, 0, 0]} position={[x, 4, i * 4]} scale={[4, 1, 1]} />
        ))}
        <Lightformer intensity={0.5} rotation-y={Math.PI / 2} position={[-5, 1, -1]} scale={[50, 2, 1]} />
        <Lightformer intensity={0.5} rotation-y={Math.PI / 2} position={[-5, -1, -1]} scale={[50, 2, 1]} />
        <Lightformer intensity={0.5} rotation-y={-Math.PI / 2} position={[10, 1, 0]} scale={[50, 2, 1]} />
      </group>
      <group ref={ref}>
        <Lightformer intensity={10} form="ring" color={pLight1.color} rotation-y={Math.PI / 2} position={[-5, 2, -1]} scale={[10, 10, 1]} />
      </group>
    </Environment>
  )
}
